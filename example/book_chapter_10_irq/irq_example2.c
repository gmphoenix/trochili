#include "example.h"
#include "trochili.h"

#if (EVB_EXAMPLE == CH10_IRQ_ASR_EXAMPLE)

/* 用户线程参数 */
#define THREAD_LED_STACK_BYTES  (512)
#define THREAD_LED_PRIORITY     (5)
#define THREAD_LED_SLICE        (20)

#define THREAD_KEY_ASR_STACK_BYTES    (512)
#define THREAD_KEY_ASR_PRIORITY       (5)
#define THREAD_KEY_ASR_SLICE          (20)

/* 用户线程栈定义 */
static TBase32 ThreadLedStack[THREAD_LED_STACK_BYTES/4];
static TBase32 ThreadKeyASRStack[THREAD_KEY_ASR_STACK_BYTES/4];

/* 用户线程定义 */
static TThread ThreadLed;
static TThread ThreadKeyASR;

/* 用户信号量定义 */
static TSemaphore LedSemaphore;


/* 评估板按键中断处理函数 */
static TBitMask EvbKeyISR(TArgument data)
{
    if (EvbKeyScan())
    {
        return  TCLR_IRQ_ASR;
    }

    return TCLR_IRQ_DONE;
}


/* 评估板按键中断处理线程主函数。
   本函数执行完毕后自动由内核挂起，所以不能是死循环。
   等到下一次中断时会再次被ISR解挂  */
static void KeyAsyncIsrEntry(TArgument data)
{
    TState state;
    TError error;

    /* 非阻塞方式释放信号量 */
    state = TclReleaseSemaphore((TSemaphore*)data, TCLO_IPC_DUMMY, 0, &error);
    TCLM_ASSERT((state == eSuccess), "");
    TCLM_ASSERT((error == TCLE_IPC_NONE), "");
}


/* Led线程的主函数 */
static void ThreadLedEntry(TArgument arg)
{
    TError error;
    TState state;

    while (eTrue)
    {
        /* Led线程以阻塞方式获取信号量，如果成功则点亮Led */
        state = TclObtainSemaphore((TSemaphore*)arg, TCLO_IPC_WAIT, 0, &error);
        if (state == eSuccess)
        {
            TCLM_ASSERT((error == TCLE_IPC_NONE), "");
            EvbLedControl(LED2, LED_ON);
        }

        /* Led线程以阻塞方式获取信号量，如果成功则熄灭Led */
        state = TclObtainSemaphore((TSemaphore*)arg, TCLO_IPC_WAIT, 0, &error);
        if (state == eSuccess)
        {
            TCLM_ASSERT((error == TCLE_IPC_NONE), "");
            EvbLedControl(LED2, LED_OFF);
        }
    }
}


/* 用户应用程序入口函数 */
static void AppSetupEntry(void)
{
    TState state;
    TError error;

    /* 初始化信号量 */
    state = TclCreateSemaphore(&LedSemaphore, 0U, 1u, TCLP_IPC_DUMMY, &error);
    TCLM_ASSERT((state == eSuccess), "");
    TCLM_ASSERT((error == TCLE_IPC_NONE), "");

    /* 设置和KEY相关的外部中断向量 */
    state = TclSetIrqVector(KEY_IRQ_ID, &EvbKeyISR, &ThreadKeyASR, (TArgument)0, &error);
    TCLM_ASSERT((state == eSuccess), "");
    TCLM_ASSERT((error == TCLE_IRQ_NONE), "");

    /* 初始化Led线程 */
    state = TclCreateThread(&ThreadLed,
                          &ThreadLedEntry,
                          (TArgument)(&LedSemaphore),
                          ThreadLedStack,
                          THREAD_LED_STACK_BYTES,
                          THREAD_LED_PRIORITY,
                          THREAD_LED_SLICE,
                          &error);
    TCLM_ASSERT((state == eSuccess), "");
    TCLM_ASSERT((error == TCLE_THREAD_NONE), "");

    /* 初始化KEY异步中断线程，该线程自动激活并处于挂起状态,不需要用户程序控制 */
    state = TclCreateAsyISR(&ThreadKeyASR,
                            &KeyAsyncIsrEntry,
                            (TArgument)(&LedSemaphore),
                            ThreadKeyASRStack,
                            THREAD_KEY_ASR_STACK_BYTES,
                            &error);
    TCLM_ASSERT((state == eSuccess), "");
    TCLM_ASSERT((error == TCLE_THREAD_NONE), "");

    /* 激活Led线程 */
    state = TclActivateThread(&ThreadLed, &error);
    TCLM_ASSERT((error == TCLE_THREAD_NONE), "");
    TCLM_ASSERT((state == eSuccess), "");
}


/* 处理器BOOT之后会调用main函数，必须提供 */
int main(void)
{
    /* 注册各个内核函数,启动内核 */
    TclStartKernel(&AppSetupEntry,
                   &CpuSetupEntry,
                   &EvbSetupEntry,
                   &EvbTraceEntry);
    return 1;
}

#endif

